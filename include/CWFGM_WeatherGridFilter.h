/**
 * WISE_Weather_Module: CWFGM_WeatherGridFilter.h
 * Copyright (C) 2023  WISE
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "WeatherCOM.h"
#include "ICWFGM_CommonBase.h"
#include "ICWFGM_GridEngine.h"
#include "CWFGM_internal.h"
#include "WTime.h"
#include "poly.h"
#include <map>

#include "FwiCom.h"
#include "ISerializeProto.h"
#include "weatherGridFilter.pb.h"

using namespace HSS_Time;

class SerializeWeatherGridFilterData : public ISerializationData
{
public:
	std::vector<std::string> *permissible_drivers;
};

#ifdef HSS_SHOULD_PRAGMA_PACK
#pragma pack(push, 8)
#endif


/**
	This object manages a collection of polygons and rules to impose 'weather patches' onto calculated weather data.  This object is unconcerned about
	how other weather data has been provided: if times and other input data are valid, then this object will apply the weather patch according to the
	defined rules.  \n\n This object will also update any FWI calculations required based on options and input values. \n\n No weather streams or
	weather stations are associated with this object since it simply updates and replaces weather values based on the patch rules.
*/
class WEATHERCOM_API CCWFGM_WeatherGridFilter : public ICWFGM_GridEngine, public ISerializeProto {

#ifndef DOXYGEN_IGNORE_CODE
public:
	friend class CWFGM_WeatherGridFilterHelper;
	CCWFGM_WeatherGridFilter();
	CCWFGM_WeatherGridFilter(const CCWFGM_WeatherGridFilter &toCopy);
	~CCWFGM_WeatherGridFilter();

#endif
public:
	/**
		Creates a new weather filter with all the same properties and data of the object being called, returns a handle to the new object in 'newFilter'.
		No data is shared between these two objects, an exact copy is created.
		\param	newFilter	A weather stream object.
		\retval	E_POINTER	The address provided for "newFilter" is invalid.
		\retval	S_OK	Successful.
		\retval	E_OUTOFMEMORY	Insufficient memory.
		\retval	ERROR_SEVERITY_WARNING	Unspecified failure.
		\retval	E_NOINTERFACE	Internal serialization issue.
	*/
	virtual NO_THROW HRESULT Clone(boost::intrusive_ptr<ICWFGM_CommonBase> *newObject) const override;
	/**
		Polymorphic.  This routine retrieves an attribute/option value given the attribute/option index.
		\param option	The attribute of interest.  Valid attributes are:
		<ul>
		<li><code>CWFGM_WEATHER_OPTION_START_TIME</code>	64-bit unsigned integer.  GMT time provided as seconds since Midnight January 1, 1600
		<li><code>CWFGM_WEATHER_OPTION_END_TIME</code>		64-bit unsigned integer.  GMT time provided as seconds since Midnight January 1, 1600
		<li><code>CWFGM_GRID_ATTRIBUTE_TIMEZONE_ID</code>	32-bit unsigned integer.  A unique ID for a pre-defined set of timezone settings. The timezone information can be retrieved using <code>WorldLocation::TimeZoneFromId</code>.
		<li><code>CWFGM_GRID_ATTRIBUTE_TIMEZONE</code>		64-bit signed integer.  Units are in seconds, relative to GMT.  For example, MST (Mountain Standard Time) would be -6 * 60 * 60 seconds.  Valid values are from -12 hours to +12 hours.
		<li><code>CWFGM_GRID_ATTRIBUTE_DAYLIGHT_SAVINGS</code>	64-bit signed integer.  Units are in seconds.  Amount of correction to apply for daylight savings time.
		<li><code>CWFGM_GRID_ATTRIBUTE_DST_START</code>	64-bit unsigned integer.  Units are in seconds.  Julian date determining when daylight savings starts within the calendar year.
		<li><code>CWFGM_GRID_ATTRIBUTE_DST_END</code>	64-bit unsigned integer.  Units are in seconds.  Julian date determining when daylight savings ends within the calendar year.
		<li><code>CWFGM_ATTRIBUTE_LOAD_WARNING</code>	BSTR.  Any warnings generated by the COM object when deserializating.
		</ul>
		\param value	Location for the retrieved value to be placed.
		\sa ICWFGM_GridEngine::GetAttribute
		\retval E_POINTER	value is NULL
		\retval E_INVALIDARG	unknown requested option
		\retval S_OK Success
	*/
	virtual NO_THROW HRESULT GetAttribute(std::uint16_t option, PolymorphicAttribute *value);
	/**
		Sets the value of an "option" to the value of the "value" variable provided.  It is important to set the starting codes of the weather stream before importing the weather data.  Changing the starting codes after importing mean Prometheus will recalculate everything.
		\param	option	The weather option of interest.  Valid options are:
		<ul>
		<li><code>CWFGM_WEATHER_OPTION_START_TIME</code>	64-bit unsigned integer.  GMT time provided as seconds since Midnight January 1, 1600
		<li><code>CWFGM_WEATHER_OPTION_END_TIME</code>		64-bit unsigned integer.  GMT time provided as seconds since Midnight January 1, 1600
		</ul>
		\param	value	The value to set the option to.
		\retval	S_OK	Successful.
		\retval	ERROR_WEATHER_OPTION_INVALID	The weather option referred to is unknown.
		\retval	E_INVALIDARG	If value's value is incorrect.	
		\retval	ERROR_SCENARIO_SIMULATION_RUNNING	Cannot set an attribute if the simulation is running.
		\retval	E_FAIL 	Failed.
	*/
	virtual NO_THROW HRESULT SetAttribute(std::uint16_t option, const PolymorphicAttribute &value);

	/**
		This method imports polygons from the specified file.  If the file is an ArcInfo Generate file, then it will use a projection file (same name, but ".prj" for an extension).  This projection file is optional.
		Other file formats will use GDAL/OGR conventions regarding projection files.  Imported data is automatically reprojected into the grid projection during import.
		\param	file_path	File path of the polygon to import.
		\param	permissible_drivers	Array of drivers (known by GDAL) identifying the file types that are allowed to be imported.
		\retval	S_OK	Successful.
		\retval	E_POINTER	Address provided for file_path is invalid.
		\retval	ERROR_FIREBREAK_NOT_FOUND	Polygon does not exist.
		\retval	E_OUTOFMEMORY	Insufficient memory.
		\retval	ERROR_GRID_UNINITIALIZED	Grid object not initialized.
		\retval	ERROR_SEVERITY_WARNING	Unspecified failure.
		\retval	S_FALSE	If asking for values where the appropriate array has not been initialized.
		\retval	E_INVALIDARG	Invalid arguments.
		\retval	ERROR_FILE_NOT_FOUND	The file cannot be found.
		\retval	ERROR_TOO_MANY_OPEN_FILES	The program has too many open files.
		\retval	ERROR_ACCESS_DENIED	Access is denied.
		\retval	ERROR_INVALID_HANDLE	Generic file I/O error.
		\retval	ERROR_HANDLE_DISK_FULL Disk full
		\retval	ERROR_FILE_EXISTS	File already exists.
	*/
	virtual NO_THROW HRESULT ImportPolygons(const std::string & file_path, const std::vector<std::string> *permissible_drivers);
	/**
		This method imports polygons from the specified WFS, looking in the identified layer.  Imported data is automatically reprojected into the grid projection during import.
		\param	url		Identifies the WFS provider.
		\param	layer	Identifies the layer in the WFS provider.
		\param	username Username for access, if needed.
		\param	password Password for the user, if needed.
		\retval	S_OK	Successful.
		\retval	E_POINTER	Address provided for any of the parameters is invalid.
		\retval	ERROR_FIREBREAK_NOT_FOUND	Polygon does not exist.
		\retval	E_OUTOFMEMORY	Insufficient memory.
		\retval	ERROR_GRID_UNINITIALIZED	Grid object not initialized.
		\retval	ERROR_SEVERITY_WARNING	Unspecified failure.
		\retval	S_FALSE	If asking for values where the appropriate array has not been initialized.
		\retval	E_INVALIDARG	Invalid arguments.
	*/
	virtual NO_THROW HRESULT ImportPolygonsWFS(const std::string & url, const std::string & layer, const std::string & username, const std::string & password);
	/**
		This method exports polygons to the specified file.  The projection file is optionally created, and will be the grid's projection.  Driver names are defined by GDAL/OGR, plus "ARCInfo Generate".
		\param	driver_name	Driver name related information
		\param	projection	Projection file for the exported polygon.
		\param	file_path	File name and path for the polygon.
		\retval	S_OK	Successful.
		\retval	E_POINTER	Address provided for file_path, driver_name, or projection is invalid.
		\retval	E_FAIL	No polygons to export
		\retval	E_OUTOFMEMORY	Insufficient memory.
		\retval	ERROR_GRID_UNINITIALIZED	Grid object not initialized.
		\retval	ERROR_SEVERITY_WARNING	Unspecified failure.
		\retval	S_FALSE	If asking for values where the appropriate array has not been initialized.
		\retval	E_INVALIDARG	Invalid arguments.
	*/
	virtual NO_THROW HRESULT ExportPolygons(const std::string & driver_name, const std::string & projection, const std::string & file_path);
	/**
		This method exports polygons to the specified WFS, to the identified layer.  Exported data is in the grid's projection.
		\param	url		Identifies the WFS provider.
		\param	layer	Identifies the layer in the WFS provider.
		\param	username Username for access, if needed.
		\param	password Password for the user, if needed.
		\retval	S_OK	Successful.
		\retval	E_POINTER	Address provided for file_path, driver_name, or projection is invalid.
		\retval	E_FAIL	Generic failure code.
		\retval	E_OUTOFMEMORY	Insufficient memory.
		\retval	ERROR_GRID_UNINITIALIZED	Grid object not initialized.
		\retval	ERROR_SEVERITY_WARNING	Unspecified failure.
		\retval	S_FALSE	If asking for values where the appropriate array has not been initialized.
		\retval	E_INVALIDARG	Invalid arguments.
	*/
	virtual NO_THROW HRESULT ExportPolygonsWFS(const std::string & url, const std::string & layer, const std::string & username, const std::string & password);

	/**
		This method adds a polygon defining an area to apply the replacement filter, to the grid filter.  A grid filter can contain many polygons, and polygons can be overlapping.
		However, only one rule applies to all polygons.  Polygons are provided in grid units.
		\param xy_pairs 2D Array of coordinates
		\param	set_break	Index of polygon.
		\retval	S_OK	Successful.
		\retval	E_POINTER	Address provided for index, or xy_pairs is invalid.
		\retval	E_FAIL		Returned if the provided polygon has less than 3 points.
		\retval	E_OUTOFMEMORY	Insufficient memory.
		\retval	ERROR_SCENARIO_SIMULATION_RUNNING	Value cannot be changed as it is being used in a currently running scenario.
	*/
	virtual NO_THROW HRESULT AddPolygon(const XY_PolyConst &xy_pairs, std::uint32_t *set_break);
	/**
		 This method clears the specified polygon.  If index = (unsigned long) -1, then all polygons are cleared.
		\param	index	Index of polygon.
		\retval	S_OK	Successful.
		\retval	ERROR_FIREBREAK_NOT_FOUND	Polygon does not exist.
		\retval	ERROR_SCENARIO_SIMULATION_RUNNING	Value cannot be changed as it is being used in a currently running scenario.
	*/
	virtual NO_THROW HRESULT ClearPolygon(std::uint32_t index);
	/**
		 This method returns the bounding box of a specific polygon, or of all polygons in the grid filter.
		\param	index	Index of polygon.
		\param	min_pt	Minimum coordinate.
		\param	max_pt	Maximum coordinate.
		\retval	S_OK	Successful.
		\retval	E_POINTER	Address provided for x_min, x_max, y_min, or y_max is invalid.
		\retval	ERROR_FIREBREAK_NOT_FOUND	Polygon does not exist.
	*/
	virtual NO_THROW HRESULT GetPolygonRange(std::uint32_t index, XY_Point* min_pt, XY_Point* max_pt);
	/**
		This method retrieves a polygon from the grid.  Polygons are retrieved in grid units.
		\param	index	Index of polygon.
		\param	size	Size of polygon.
		\param xy_pairs 2D Array of coordinates
		\retval	S_OK	Successful.
		\retval	E_POINTER	Address provided for size, or xy_pairs is invalid.
		\retval	ERROR_FIREBREAK_NOT_FOUND	Polygon does not exist.
		\retval	E_OUTOFMEMORY	Insufficient memory.
	*/
	virtual NO_THROW HRESULT GetPolygon(std::uint32_t index, std::uint32_t *size, XY_Poly *xy_pairs);
	/**
		 This method retrieves the area of the grid filter.  Note that this function does not consider overlapping polygons.
		\param	area	Pointer to the retrieves data.
		\retval	S_OK	Successful.
		\retval	E_POINTER	Address provided for area is invalid.
	*/
	virtual NO_THROW HRESULT GetArea(double *area);
	/**
		 This method gets the number of polygons in the grid.
		\param	count	Number of polygons
		\retval	S_OK	Successful.
		\retval	E_POINTER	Address provided for count is invalid.
	*/
	virtual NO_THROW HRESULT GetPolygonCount(std::uint32_t *count);
	/**
		This method gets polygon size (number of vertices).  Or, if index = -1, then this method gets the maximum size (number of vertices) of the polygons in the grid filter.
		\param	index	Index of polygon.
		\param	size	Size of polygon.
		\retval	S_OK	Successful.
		\retval	E_POINTER	Address provided for size is invalid.
		\retval	ERROR_FIREBREAK_NOT_FOUND	Polygon does not exist.
	*/
	virtual NO_THROW HRESULT GetPolygonSize(std::uint32_t index, std::uint32_t *size);

	/**
		Gets Temperature value.  How this temperature value is to be interpretted depends on TemperatureOperation.
		\sa ICWFGM_WeatherGridFilter::Temperature
		\sa ICWFGM_WeatherGridFilter::TemperatureOperation
		\param	pVal	Temperature Value
	*/
	virtual NO_THROW HRESULT get_Temperature(double *pVal);
	/**
		Sets Temperature value.  How this temperature value is used depends on TemperatureOperation.
		\param	newVal	New Temperature Value (Celsius)
	*/
	virtual NO_THROW HRESULT put_Temperature(double newVal);
	/**
		Gets Relative Humidity value.  How this RH value is to be interpretted depends on RHOperation.
		\sa ICWFGM_WeatherGridFilter::RH
		\sa ICWFGM_WeatherGridFilter::RHOperation
		\param	pVal	Relative Humidity Value
	*/
	virtual NO_THROW HRESULT get_RH(double *pVal);
	/**
		Sets Relative Humidity value.  How this RH value is used depends on RHOperation.
		\param	newVal	New Relative Humidity Value
	*/
	virtual NO_THROW HRESULT put_RH(double newVal);
	/**
		Gets Precipitation value.  How this precipitation value is to be interpretted depends on PrecipitationOperation.
		\sa ICWFGM_WeatherGridFilter::Precipitation
		\sa ICWFGM_WeatherGridFilter::PrecipitationOperation
		\param	pVal	Precipitation Value
	*/
	virtual NO_THROW HRESULT get_Precipitation(double *pVal);
	/**
		Sets Precipitation value.  How this precipitation value is used depends on PrecipitationOperation.
		\param	newVal	New Precipitation Value	
	*/
	virtual NO_THROW HRESULT put_Precipitation(double newVal);
	/**
		Gets Wind Speed value.  How this wind speed value is to be interpretted depends on WindSpeedOperation.
		\sa ICWFGM_WeatherGridFilter::WindSpeed
		\sa ICWFGM_WeatherGridFilter::WindSpeedOperation
		\param	pVal	Wind Speed Value
	*/
	virtual NO_THROW HRESULT get_WindSpeed(double *pVal);
	/**
		Sets Wind Speed value.  How this wind direction value is used depends on WindDirectionOperation.
		\param	newVal	New Wind Speed Value
	*/
	virtual NO_THROW HRESULT put_WindSpeed(double newVal);
	/**
		Gets Wind Direction value.  How this wind direction value is to be interpretted depends on WindDirectionOperation.
		\sa ICWFGM_WeatherGridFilter::WindDirection
		\sa ICWFGM_WeatherGridFilter::WindDirectionOperation
		\param 	pVal  Wind Direction Value
	*/
	virtual NO_THROW HRESULT get_WindDirection(double *pVal);
	/**
		Sets Wind Direction value.  How this wind direction value is used depends on WindDirectionOperation.
		\param	newVal	New Wind Direction Value
	*/
	virtual NO_THROW HRESULT put_WindDirection(double newVal);

	/**
		Gets Temperature Operation value
		\sa ICWFGM_WeatherGridFilter::Temperature
		\sa ICWFGM_WeatherGridFilter::TemperatureOperation
		\param	pVal	Temperature Operation Value
		<ul>
		<li>0: simple assignment / replacement
		<li>1: additive
		<li>2: subtraction
		<li>3: multiplicative
		<li>4: division
		</ul>
	*/
	virtual NO_THROW HRESULT get_TemperatureOperation(std::uint16_t *pVal);
	/**
		Sets Temperature Operation value
		\param	newVal	New Temperature Operation Value.  Valid values are:
		<ul>
		<li>0: simple assignment / replacement
		<li>1: additive
		<li>2: subtraction
		<li>3: multiplicative
		<li>4: division
		</ul>
	*/
	virtual NO_THROW HRESULT put_TemperatureOperation(std::uint16_t newVal);
	/**
		Gets Relative Humidity Operation value
		\sa ICWFGM_WeatherGridFilter::RH
		\sa ICWFGM_WeatherGridFilter::RHOperation
		\param	pVal	Relative Humidity Operation Value
		<ul>
		<li>0: simple assignment / replacement
		<li>1: additive
		<li>2: subtraction
		<li>3: multiplicative
		<li>4: division
		</ul>
	*/
	virtual NO_THROW HRESULT get_RHOperation(std::uint16_t *pVal);
	/**
		Sets Relative Humidity Operation value
		\sa ICWFGM_WeatherGridFilter::RH
		\sa ICWFGM_WeatherGridFilter::RHOperation
		\param	newVal	New Relative Humidity Operation Value.  Valid values are:
		<ul>
		<li>0: simple assignment / replacement
		<li>1: additive
		<li>2: subtraction
		<li>3: multiplicative
		<li>4: division
		</ul>
	*/
	virtual NO_THROW HRESULT put_RHOperation(std::uint16_t newVal);
	/**
		Gets Precipitation Operation value
		\sa ICWFGM_WeatherGridFilter::Precipitation
		\sa ICWFGM_WeatherGridFilter::PrecipitationOperation
		\param	pVal	Precipitation Operation Value
		<ul>
		<li>0: simple assignment / replacement
		<li>1: additive
		<li>2: subtraction
		<li>3: multiplicative
		<li>4: division
		</ul>
	*/
	virtual NO_THROW HRESULT get_PrecipitationOperation(std::uint16_t *pVal);
	/**
		Sets Precipitation Operation value
		\sa ICWFGM_WeatherGridFilter::Precipitation
		\sa ICWFGM_WeatherGridFilter::PrecipitationOperation
		\param	newVal	New Precipitation Operation Value.  Valid values are:
		<ul>
		<li>0: simple assignment / replacement
		<li>1: additive
		<li>2: subtraction
		<li>3: multiplicative
		<li>4: division
		</ul>
	*/
	virtual NO_THROW HRESULT put_PrecipitationOperation(std::uint16_t newVal);
	/**
		Gets Wind Speed Operation value
		\sa ICWFGM_WeatherGridFilter::WindSpeed
		\sa ICWFGM_WeatherGridFilter::WindSpeedOperation
		\param	pVal	Wind Speed Operation Value
		<ul>
		<li>0: simple assignment / replacement
		<li>1: additive
		<li>2: subtraction
		<li>3: multiplicative
		<li>4: division
		</ul>
	*/
	virtual NO_THROW HRESULT get_WindSpeedOperation(std::uint16_t *pVal);
	/**
		Sets Wind Speed Operation value
		\sa ICWFGM_WeatherGridFilter::WindSpeed
		\sa ICWFGM_WeatherGridFilter::WindSpeedOperation
		\param	newVal	New Wind Speed Operation Value.  Valid values are:
		<ul>
		<li>0: simple assignment / replacement
		<li>1: additive
		<li>2: subtraction
		<li>3: multiplicative
		<li>4: division
		</ul>
	*/
	virtual NO_THROW HRESULT put_WindSpeedOperation(std::uint16_t newVal);
	/**
		Gets Wind Direction Operation value
		\sa ICWFGM_WeatherGridFilter::WindDirection
		\sa ICWFGM_WeatherGridFilter::WindDirectionOperation
		\param	pVal	Wind Direction Operation Value
		<ul>
		<li>0: simple assignment / replacement
		<li>1: additive
		<li>2: subtraction
		</ul>
	*/
	virtual NO_THROW HRESULT get_WindDirectionOperation(std::uint16_t *pVal);
	/**
		Sets Wind Direction Operation value
		\sa ICWFGM_WeatherGridFilter::WindDirection
		\sa ICWFGM_WeatherGridFilter::WindDirectionOperation
		\param	newVal	New Wind Direction Operation Value.  Valid values are:
		<ul>
		<li>0: simple assignment / replacement
		<li>1: additive
		<li>2: subtraction
		</ul>
	*/
	virtual NO_THROW HRESULT put_WindDirectionOperation(std::uint16_t newVal);

	/**
		Changes the state of the object with respect to access rights.  When the object is used by an active simulation, it must not be modified.
		When the object is somehow modified, it must be done so in an atomic action to prevent concerns with arising from multithreading.
		Note that these locks are primarily needed to ensure that data contributing during a simulation is not modified while the simulation is executing.\n\n All routines in the
		ICWFGM_GridEngine interface are necessarily NOT multithreading safe (for performance) but other interfaces for a given COM object
		implementing this interface must be by specification.  Locking request is forwarded to the next lower object in the 'layerThread' layering.\n\n
		In the event of an error, then locking is undone to reflect an error state.
		\param	layerThread		Handle for scenario layering/stack access, allocated from an ICWFGM_LayerManager COM object.  Needed.  It is designed to allow nested layering analogous to the GIS layers.
		\param	exclusive	true if the requester wants a write lock, false for read/shared access
		\param	obtain	true to obtain the lock, false to release the lock.  If this is false, then the 'exclusive' parameter must match the initial call used to obtain the lock.
		\sa ICWFGM_GridEngine::MT_Lock
		\retval	SUCCESS_STATE_OBJECT_UNLOCKED	Lock was released.
		\retval	SUCCESS_STATE_OBJECT_LOCKED_WRITE	Exclusive/write lock obtained.
		\retval	SUCCESS_STATE_OBJECT_LOCKED_SCENARIO	A scenario successfully required a lock for purposes of simulating.
		\retval	SUCCESS_STATE_OBJECT_LOCKED_READ	Shared/read lock obtained.
		\retval	S_OK	Successful
		\retval	ERROR_GRID_UNINITIALIZED	No path via layerThread can be determined to further determine successful locks.
	*/
	virtual NO_THROW HRESULT MT_Lock(Layer *layerThread, bool exclusive, std::uint16_t obtain) override;
	/**
		Polymorphic.  If layerThread is non-zero, then this filter object simply forwards the call to the next lower GIS
		layer determined by layerThread.  If layerthread is zero, then this object will interpret the call.
		\param	layerThread		Handle for scenario layering/stack access, allocated from an ICWFGM_LayerManager COM object.  Needed.  It is designed to allow nested layering analogous to the GIS layers.
		\param option	The attribute of interest.  Valid attributes are:
		<ul>
		<li><code>CWFGM_WEATHER_OPTION_START_TIME</code>	64-bit unsigned integer.  GMT time provided as seconds since Midnight January 1, 1600
		<li><code>CWFGM_WEATHER_OPTION_END_TIME</code>		64-bit unsigned integer.  GMT time provided as seconds since Midnight January 1, 1600
		<li><code>CWFGM_GRID_ATTRIBUTE_TIMEZONE_ID</code>	32-bit unsigned integer.  A unique ID for a pre-defined set of timezone settings. The timezone information can be retrieved using <code>WorldLocation::TimeZoneFromId</code>.
		<li><code>CWFGM_GRID_ATTRIBUTE_TIMEZONE</code>		64-bit signed integer.  Units are in seconds, relative to GMT.  For example, MST (Mountain Standard Time) would be -6 * 60 * 60 seconds.  Valid values are from -12 hours to +12 hours.
		<li><code>CWFGM_GRID_ATTRIBUTE_DAYLIGHT_SAVINGS</code>	64-bit signed integer.  Units are in seconds.  Amount of correction to apply for daylight savings time.
		<li><code>CWFGM_GRID_ATTRIBUTE_DST_START</code>	64-bit unsigned integer.  Units are in seconds.  Julian date determining when daylight savings starts within the calendar year.
		<li><code>CWFGM_GRID_ATTRIBUTE_DST_END</code>	64-bit unsigned integer.  Units are in seconds.  Julian date determining when daylight savings ends within the calendar year.
		<li><code>CWFGM_ATTRIBUTE_LOAD_WARNING</code>	BSTR.  Any warnings generated by the COM object when deserializating.
		</ul>
		\param value	Location for the retrieved value to be placed.
		\sa ICWFGM_GridEngine::GetAttribute
		\retval E_POINTER	value is NULL
		\retval	ERROR_GRID_UNINITIALIZED	No object in the grid layering to forward the request to.
		\retval S_OK Success
	*/
	virtual NO_THROW HRESULT GetAttribute(Layer *layerThread, std::uint16_t option, PolymorphicAttribute *value) override;
	/**
		This object conditionally updates weather at location (x, y) at time 'time'.  'interpolate_method' determines various rules for how FWI calculations take place: if FWI calculations
		are being recursively calculated back in time, etc.  All weather and fwi calculations are performed (as requested and determined).  Note that some modes require a potentially long-
		duration recursive calculation to take place, which may take some time (and stack space) to perform.
		\param	layerThread		Handle for scenario layering/stack access, allocated from an ICWFGM_LayerManager COM object.  Needed.  It is designed to allow nested layering analogous to the GIS layers.
		\param	pt			Location.
		\param	time	A GMT time.
		\param	interpolate_method		Interpolation method identifier.  Valid bit-flag identifiers are:
		<ul>
		<li><code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_SPATIAL</code> Boolean.  When true, spatial weather interpolation is turned on.  This option applies to both WX and FWI values, and will work whether there is 1 or more weather stations assigned to the scenario.  If false, then there should only be one weather stream.
		<li><code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_CALCFWI</code> Boolean.  If false, then the current FWI values are returned (possibly interpolated).  If true, then the current FWI values are calculated from the prior FWI values and the current weather values (likely spatially interpolated).
		<li><code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_HISTORY</code> Boolean.  Conditional on <code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_SPATIAL</code> and <code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_CALCFWI</code>.  If true, then historical FWI values are calculated to try to attain equilibrium on FWI values.
		<li><code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_TEMPORAL</code> Boolean.  When true, temporal weather interpolation is turned on, for all of the WX and hourly/instantantaneous FWI calculations.
		</ul>
		\param	wx			Weather information.
		\param	ifwi		IFWI Information.
		\param	dfwi		DFWI Information.
		\sa ICWFGM_GridEngine::GetWeatherData
		\retval	CWFGM_WEATHER_INITIAL_VALUES_ONLY	Given time, only initial weather values (used for starting FWI calculations) could be returned.	
		\retval ERROR_INVALID_DATA			Invalid latitude/longitude available for calculations.
		\retval E_INVALIDARG				Error in calculations (likely FWI calculations).
		\retval E_POINTER				Invalid wx, ifwi, or dfwi pointers.
		\retval S_OK					Calculations are successful
	*/
	virtual NO_THROW HRESULT GetWeatherData(Layer *layerThread, const XY_Point &pt, const HSS_Time::WTime &time, std::uint64_t interpolate_method,
	    IWXData *wx, IFWIData *ifwi, DFWIData *dfwi, bool *wx_valid, XY_Rectangle *bbox_cache) override;
	/**
		This object conditionally updates weather at the specified location for storage in the provided array(s) at time 'time'.  'interpolate_method' determines various rules for how FWI calculations take place: if FWI calculations
		are being recursively calculated back in time, etc.  All weather and fwi calculations are performed (as requested and determined).  Note that some modes require a potentially long-
		duration recursive calculation to take place, which may take some time (and stack space) to perform.
		\param	layerThread		Handle for scenario layering/stack access, allocated from an ICWFGM_LayerManager COM object.  Needed.  It is designed to allow nested layering analogous to the GIS layers.
		\param	min_pt		Minimum value (inclusive).
		\param	max_pt		Maximum value (inclusive).
		\param	scale		Scale (meters) that the array is defined for
		\param	time	A GMT time.
		\param	interpolate_method		Interpolation method identifier.  Valid bit-flag identifiers are:
		<ul>
		<li><code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_SPATIAL</code> Boolean.  When true, spatial weather interpolation is turned on.  This option applies to both WX and FWI values, and will work whether there is 1 or more weather stations assigned to the scenario.  If false, then there should only be one weather stream.
		<li><code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_CALCFWI</code> Boolean.  If false, then the current FWI values are returned (possibly interpolated).  If true, then the current FWI values are calculated from the prior FWI values and the current weather values (likely spatially interpolated).
		<li><code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_HISTORY</code> Boolean.  Conditional on <code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_SPATIAL</code> and <code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_CALCFWI</code>.  If true, then historical FWI values are calculated to try to attain equilibrium on FWI values.
		<li><code>CWFGM_SCENARIO_OPTION_WEATHER_INTERPOLATE_TEMPORAL</code> Boolean.  When true, temporal weather interpolation is turned on, for all of the WX and hourly/instantantaneous FWI calculations.
		</ul>
		\param	wx		Array of Weather information.
		\param	ifwi		Array of Instantaneous FWI codes.
		\param	dfwi		Array of Daily FWI codes.
		\sa ICWFGM_GridEngine::GetWeatherDataArray
		\retval	ERROR_GRID_UNINITIALIZED	No object in the grid layering to forward the request to.
		\retval E_INVALIDARG	The array is not 2D, or is insufficient in size to contain the requested data
	*/
	virtual NO_THROW HRESULT GetWeatherDataArray(Layer *layerThread, const XY_Point &min_pt,const XY_Point &max_pt, double scale,const HSS_Time::WTime &time, std::uint64_t interpolate_method,
			IWXData_2d *wx, IFWIData_2d *ifwi, DFWIData_2d *dfwi, bool_2d *wx_valid) override;
	/**
		This method will examine start and end dates and diurnal periods to determine the time at which the next event for known change in weather data occurs.
		This filter object it will then forward the call to the next lower GIS layer determined by layerThread and combine results.
		\param	layerThread		Handle for scenario layering/stack access, allocated from an ICWFGM_LayerManager COM object.  Needed.  It is designed to allow nested layering analogous to the GIS layers.
		\param	flags	Calculation flags.  Valid bit-flag identifiers are:
		<ul>
		<li><code>CWFGM_GETEVENTTIME_FLAG_SEARCH_FORWARD</code> search forward in time
		<li><code>CWFGM_GETEVENTTIME_FLAG_SEARCH_BACKWARD</code> search backwards in time
		<li><code>CWFGM_GETEVENTTIME_QUERY_PRIMARY_WX_STREAM</code> only the primary weather stream may respond
		<li><code>CWFGM_GETEVENTTIME_QUERY_ANY_WX_STREAM</code> only weather streams may respond
		</ul>
		\param	from_time	A GMT time provided as seconds since January 1st, 1600.
		\param	next_event	A GMT time provided as seconds since January 1st, 1600, representing the time for the next event, based on 'flags'.
		\sa ICWFGM_GridEngine::GetEventTime
		\retval	ERROR_GRID_UNINITIALIZED	No object in the grid layering to forward the request to.
	*/
	virtual NO_THROW HRESULT GetEventTime(Layer *layerThread, const XY_Point& pt, std::uint32_t flags, const HSS_Time::WTime &from_time, HSS_Time::WTime *next_event, bool* event_valid) override;
	virtual NO_THROW HRESULT PutGridEngine(Layer *layerThread, ICWFGM_GridEngine * newVal) override;
	virtual NO_THROW HRESULT PutCommonData(Layer* layerThread, ICWFGM_CommonData* pVal) override;

#ifndef DOXYGEN_IGNORE_CODE
protected:
	CRWThreadSemaphore		m_lock, m_calcLock;

	WTimeManager			*m_timeManager;

	std::string				m_gisURL, m_gisLayer, m_gisUID, m_gisPWD;
	double					m_resolution, m_iresolution, m_xllcorner, m_yllcorner;
	double					m_poly_ws_val, m_poly_wd_val, m_poly_temp_val, m_poly_rh_val, m_poly_precip_val;
	std::uint16_t			m_poly_ws_op, m_poly_wd_op, m_poly_temp_op, m_poly_rh_op, m_poly_precip_op, m_pad;
	bool					m_landscape{ false };

	WTime					m_lStartTime, m_lEndTime;
	XY_PolyLLSet			m_polySet;
	std::string				m_loadWarning;
	unsigned long			m_flags;					// see CWFGM_internal.h for available options
	bool					m_bRequiresSave;

    protected:

	std::uint16_t convertX(double x, XY_Rectangle *bbox);
	std::uint16_t convertY(double y, XY_Rectangle *bbox);
	double invertX(double x)			{ return x * m_resolution + m_xllcorner; }
	double invertY(double y)			{ return y * m_resolution + m_yllcorner; }
	HRESULT fixResolution();

	HRESULT getWeatherData(ICWFGM_GridEngine *gridEngine, Layer *layerThread, const XY_Point &pt, const HSS_Time::WTime &time, std::uint64_t interpolate_method, IWXData *wx, IFWIData *ifwi, DFWIData *dfwi, bool *wx_valid, XY_Rectangle *bbox_cache);	
	bool GetWeatherInfoInPoly(const XY_Point &pt, IWXData *wx, bool *wx_valid);

public:
	virtual std::int32_t serialVersionUid(const SerializeProtoOptions& options) const noexcept override;
	virtual WISE::WeatherProto::WeatherGridFilter* serialize(const SerializeProtoOptions& options) override;
	virtual CCWFGM_WeatherGridFilter *deserialize(const google::protobuf::Message& proto, std::shared_ptr<validation::validation_object> valid, const std::string& name) override;
	virtual CCWFGM_WeatherGridFilter *deserialize(const google::protobuf::Message& proto, std::shared_ptr<validation::validation_object> valid, const std::string& name, ISerializationData* data) override;
	virtual std::optional<bool> isdirty(void) const noexcept override { return m_bRequiresSave; }
#endif
};

#ifdef HSS_SHOULD_PRAGMA_PACK
#pragma pack(pop)
#endif
